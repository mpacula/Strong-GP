; a simple statically-typed scheme-like language. Used to evaluate the expressiveness and
; adequacy of the metalanguage.

; define types first

types {
      ; numeric types
      Number
      Integer derives Number
      Double derives Number

      ; character types
      Char
      String

      ; the basic types defined above are covariant, i.e. all Integers are Numbers but not vice-versa

      ; parametrized types. Parametrized types accept one or more other types and are invariant
      List a ; a can be any other type
      Pair a b ; a and b can be of any type

      ; the language will also allow chained types, which are especially useful for methods.
      ; For example, given the types above Number -> String is also a valid type, as is
      ; Number -> String -> List Number
}

rules {
      ; let's start with a few simple ones. For now, assume expr stands for any valid scheme
      ; expression
      
      add_expr -> {"(+" exprA@expr::Number exprA@expr::Number ")"}::coalesce exprA exprB

      ; the above defines a new expression type "add_expr" with only one possible expansion.
      ; Each expansion is enclosed within curly brackets {}.
      ; Types are given to the nonterminals and the whole expression using the :: operator.
      ; Only simple type expressions are allowed within each expansion. More complicated expressions
      ; such as coalesce are allowed to describe entire expansions.
      ; Nonterminals can be given names using the @ notation, with the lhs being the name
      ; and rhs being a nonterminal. The names are expansion-local and are only available
      ; in the expansions type expression.
      ; Terminals are enclosed in double quotes.

      ; What if we were to support other operations such as "-" and "*"? Operator precedence
      ; nonwithstanding, we could write something like:

      add_expr -> {"(+" exprA@expr::Number exprA@expr::Number ")"}::coalesce exprA exprB
                  {"(-" exprA@expr::Number exprA@expr::Number ")"}::coalesce exprA exprB

      ; That's an awful lot of verbosity! Instead, we could define an expansion-internal OR
      ; operator:

      add_expr -> {"(+" || "(-"  exprA@expr::Number exprA@expr::Number ")"}::coalesce exprA exprB

      ; Looks good. Now let's try declaring literals

      integer_expr -> { ['0'-'9']+ } :: Integer             ; supported operators: +,*,[]
      char_expr -> { "'" ['a'-'z'] "'" } :: Char           ; this doesn't define all possible alphanumeric 
                                                            ; identifiers, but for now it's good enough

      string_expr -> "\"" [a-z]+ "\""

      ; let's try declaring methods. First we need a way to declare argument lists (chains). Here
      ; things get a little tricky.

      arg_list -> { next_arg@arg args@arg_list::Chain } :: cons args arg
                  { new_arg@arg } :: new-chain new_arg

      ; in the rule above, arg_list is of *built-in* type Chain, which matches Integer -> String,
      ; Integer -> Integer -> Integer and all other possible chains. new_chain is a type operator
      ; that takes a single type and creates a one-element type chain

      ; What would an argument declaration look then? Remember this is static scheme, so this
      ; syntax is not standard and explicitly assigns a type to a symbol

      arg -> { symbol "::int" } :: Integer
             { symbol "::string" } :: String
             ; ... etc

      ; Now, we can create lists of arguments. For example, consider the following static scheme code:
      ; a::int b::string. Both parse to arg::Integer. Now, the rightmost would parse to a Chain with
      ; a single type element Integer. The cons type operator will then join them into Integer -> Integer
      ; Let's try declaring a lambda:

      lambda -> { "(lambda (" args@arg_list::Chain ")" all_exprs@(expr+) ")" } :: \
                   append args (type (last all_exprs))

      ; Notice we didn't give expr a type. The metalanguage has a built-in type "?", which can stand for
      ; any other type. In terms of variance, "?" is a supertype of all other types. For example
      ; any_expr::? can be expanded to an expression with any type.
      ; Another thing to notice is the "type" operator, which takes a name and returns the runtime
      ; type of the nonterminal associated with the name. For example, we could declare an identity
      ; type operator as:

      id -> { any_expr@expr::? } :: type any_expr

      ; OK, we can define lambdas and give them types. The question remains, how do we
      ; make use of function types? We use the chain notation (->):

      simple_call -> { "(" f@symbol::?->?->? arg1@expr::? arg2@expr::? ")" } :: last f

      ; simple_call defines an s-expression that starts with a function of two arguments and return value of
      ; any type. It takes two arguments of any type. The type of simple_call is whatever f returns (last
      ; type in the chain). Notice a subtle problem here. We cannot really express constraints on f
      ; other than the number of arguments. What if we want to restrict the type of f's arguments?
      ; One solution, the one we'll stick to for now, is to allow names inside chains:

      simple_call2 -> { "(" f@symbol::arg1->arg2->? arg1@expr::? arg2@expr::? ")" } :: last f

      ; That's much better. We can now say that f has to be a function, take 2 arguments, and the types
      ; of its arguments have to be the same as the arguments passed to it.
      ; There's a subtlety we have to deal with to make this work, namely the variance of chain types.
      ; What's the relation between Number->Integer and Integer->Integer? For example, we want the following
      ; type expression to typecheck (in the context if simple_call2 defined above):
      ;
      ; (Number->Integer->? Integer Integer)
      ;
      ; But the definition of simple_call2 makes it problematic, since two integer arguments
      ; mandate a function of type Integer->Integer->?. What do we make of this?
      ; The solution is to make chain types contravariant. For example, we can say
      ; that Number->Integer->? is a valid substituion for Integer->Integer->?.
      ; So far so good. What about the return type, though? Clearly contravariance
      ; of the return type is problematic. If we allow Integer->Number in place of
      ; Integer -> Integer, consumers of the return value will not expect it. As a result,
      ; the last type in the chain has to be treated as a special, covariant, case.
      ;
      ; Let's recap: Chain types are contravariant in the first n-1 elements, and covariant
      ; in the last.
      ;
      ; Some examples:
      ;
      ; Integer -> Number  ::  Number -> Integer
      ; Integer -> Integer :/: Integer -> Number (violated covariance of the return type)
      ; Number -> Integer  :/: Integer -> Integer (violated contravariance of the argument)
}
